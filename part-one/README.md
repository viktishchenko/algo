# Подбор наиболее частых вопросов на позицию фронтенд джун

**Ресурсы для js:**

- собственно js: https://learn.javascript.ru/

- js для "крепких" : http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus

[Вторая часть →](../part-two/README.md)

## Общие вопросы о веб-разработке:

<details>
<summary>Используете вы Perfect Pixel или что-то аналогичное?</summary>
<div> <br />
	Следует уточнить про допуски при верстке, 5px - 10px
</div>
</details>

<details>
<summary>Можете ли пояснить разницу между progressive enhancement и graceful degradation?</summary>
<div> <br />
	<p>graceful degradation будет пониматься как отказоустойчивость клиентских веб-интерфейсов.
	Постепенная деградация может выражаться в возможности работы при отключённом JavaScript, в достаточно аккуратном отображении интерфейса в браузере, не поддерживающем новые свойства CSS3, в адекватном отображении сайта при отключенных изображениях. В каждом из этих случаев работа пользователя с интерфейсом будет в принципе возможна, хотя и не так удобна.</p>
	<p>Что же такое progressive enhancement? Чаще всего этот термин переводят, как прогрессивное улучшение. Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре </p>
	<ul>
		<li>«Старый-добрый-HTML»</li>
		<li>«CSS»</li>
		<li>«CSS3»</li>
		<li>«JavaScript»</li>
	</ul>
	<p>
		Источник: https://htmlacademy.ru/blog/7-progressive-enhancement
	</p>
</div>
</details>

<details>
<summary>Что такое прогрессивный JPEG?</summary>
<div> <br />
	<p>Подробней: https://habrahabr.ru/post/165645/</p>
</div>
</details>

<details>
<summary>Что такое feature detection (определение возможностей браузера)?</summary>
<div> <br />
	<p>Feature detection определяет, поддерживает ли браузер тот или иной блок кода и запускает различный код в зависимости от того, поддерживает или нет, так чтобы браузер всегда мог показать рабочий код, вместо репортов об ошибках.</p>
	<b>2 способа определения в js</b>:
	<ul>
		<li>распарсить юзер-агент, определить версию браузера и писать в коде свитчи по версии браузера</li>
		<li>Проверить наличие свойства или метода в window(dom, bom, javascript):</li>
	</ul>
</div>

```javascript
if ("geolocation" in navigator) {
  navigator.geolocation.getCurrentPosition(function (position) {
    // show the location on a map, perhaps using the Google Maps API
  });
} else {
  // Give the user a choice of static maps instead perhaps
}
```

<div>
	<b>1 способ в css</b>:
	<ul>
		<li>@supports</li>
	</ul>
	<b>Подробней:</b>
	<br />
	<ul>
		<li>https://developer.mozilla.org/de/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection</li>
		<li>https://habrahabr.ru/post/336466/</li>
	</ul>
</div>
</details>

<details>
<summary>Как проверить что куки включенны?\*</summary>
<div> 
	<br />
</div>

```javascript
if (!navigator.cookieEnabled) {
  alert("Включите cookie для комфортной работы с этим сайтом");
}
```

</details>

<details>
<summary>Объясните, что означает "Семантическая разметка"</summary>
<div> <br />
	<p>Семантическая вёрстка, или семантический HTML-код, — это подход к созданию веб-страниц на языке HTML, основанный на использовании HTML-тегов в соответствии с их семантикой (предназначением), а также предполагающий логичную и последовательную иерархию страницы. Он противопоставляется подходу, при котором написание HTML-кода определяется внешним видом веб-страницы. Для оформления веб-страниц, написанных в соответствии с семантикой, используются каскадные таблицы стилей (CSS). Стандарт HTML с самого начала включал в себя ряд семантических тегов, но большую популярность семантическая вёрстка получила после начала работ над HTML5.</p>
	<p>
		Источник: https://ru.wikipedia.org/wiki/Семантическая_вёрстка
	</p>
</div>
</details>

<details>
<summary>Как можно оптимизировать загрузку внешних ресурсов на странице?</summary>
<div> <br />
	<ul>
		<li>Уменьшите количество HTTP-запросов</li>
		<li>Используйте поддомены для параллельного скачивания</li>
		<li>Используйте кэш браузера</li>
		<li>Используйте CDN для загрузки популярных JavaScript библиотек</li>
		<li>Используйте Gzip- сжатие</li>
	</ul>
	<p>
		Подробней по каждому пункту: https://habrahabr.ru/post/137239/
	</p>
</div>
</details>

<details>
<summary>Каково преимущество в подгрузке внешних ресурсов с нескольких доменов?</summary>
<div> <br />
	<p>Cогласно спецификации HTTP/1.1 на браузеры накладываются ограничения на количество одновременно загружаемых компонентов сайта, а именно не более 2-х компонентов с одного хоста. Поэтому если на Вашем сайте много графики, то ее лучше вынести на отдельный поддомен или поддомены. Для Вас это будет один и тот же сервер, а для браузера – разные. Чем больше поддоменов Вы создадите, тем больше файлов браузер сможет одновременно загрузить и тем быстрее загрузится вся страница сайта. Вам остается лишь изменить адрес картинок на новый. Очень простой, но действенный способ.
	</p>
</div>
</details>

<details>
<summary>Назовите три способа уменьшения времени загрузки страницы (воспринимаемого или реального)</summary>
<div> <br />
	<ul>
		<li>Помещайте CSS файлы в начале страницы</li>
		<li>Помещайте javascript в конец страницы</li>
		<li>Минимизируйте css и javascript</li>
		<li>Оптимизируйте ваши изображения</li>
		<li>Не масштабируйте изображения</li>
	</ul>
	<p>
		Подробней по каждому пункту: https://habrahabr.ru/post/137239/
	</p>
</div>
</details>

<details>
<summary>Что такое FOUC (Flash Of Unstyled Content)? Как его избежать?</summary>
<div> <br />
	<p>Flash of Unstyled Content (FOUC) – это кратковременное появление неоформленных HTML-элементов в некоторых версиях браузеров – сразу же после создания визуальных элементов и до полного применения стилей CSS.</p>
	<ul>
		<li>`css {display: block}` на компонент</li>
		<li>В `<head>` инлайнится код, необходимый для показа минимум 600px высоты страницы без загрузки дополнительных стилей.</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое критический путь рендеринга веб-страниц?</summary>
<div> <br />
	<p>Критический путь рендеринга – это набор минимально необходимых для начала отрисовки страницы действий, ресурсов и вычислений.</p>
	<p>Критический путь можно измерять в количестве критических ресурсов, минимальном времени загрузки (измеряется в RTT) и объеме критических ресурсов (в байтах).</p>
	<p>Для иллюстрации возьмем простейший пример: HTML страницу размером 1 кб без внешних ресурсов. Критический путь будет: 1 ресурс (HTML-документ), 1 RTT (минимально), 1 кб трафика. Однако, таких простых страниц в природе почти не встретить, поэтому покажем, как можно определять критический путь на реальных веб-страницах.</p>
	<p>
		Подробней: https://habrahabr.ru/post/262239/
	</p>
</div>
</details>

<details>
<summary>Что такое WebSQL?</summary>
<div> <br />
	<p>WebSQL DB — это API для доступа к полноценному SQL-хранилищу данных, основанному на SQLite. Впрочем, последнее обстоятельство — скорее, особенность реализации и стандартом не оговаривается, хотя диалект SQL используется именно от SQLite.</p>
	<b>Подробней:</b>
	<ul>
		<li>(en) https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Storage</li>
		<li>https://habrahabr.ru/post/84654/</li>
		<li>(Раздел: За пределами пары ключ/значение: конкурентное видение) http://htmlbook.ru/html5/storage</li>
	</ul>
</div>
</details>

<details>
<summary>Является ли WebSQL частью спецификации HTML 5?</summary>
<div> <br />
	<p>Нет. Многие относят его к HTML 5, но WebSQL не является частью спецификации HTML 5. Спецификация основана на SQLite.</p>
	<p>
		Поддержка браузерами: https://caniuse.com/#search=websql
	</p>
</div>
</details>

<details>
<summary>Является ли, Drag and drop частью спецификации? Какие drag-события Вам известны?</summary>
<div>
	<br />
	<p>Да, это часть спецификации</p>
	<p><b>dragstart</b>, <b>dragenter</b>, <b>dragover</b>, <b>dragleave</b>, <b>drag</b>, <b>drop</b>, <b>dragend</b></p>
	<p>Подробней: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Drag_and_drop#events</p>
</div>
</details>

<details>
<summary>Является ли Web workers частью спецификации HTML 5?</summary>
<div> <br />
	<p>Да. Worker - это объект, созданный при помощи конструктора (например, Worker()), который запускает JavaScript файл по имени — этот файл содержит код, который будет выполнен в потоке Worker'а; объекты Workers запускаются в другом глобальном контексте, который отличается от текущего window. Таким образом, использование переменной window для получения текущего глобального контекста (вместо self) внутри Worker вернет ошибку.</p>
	<b></b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/DOM/Using_web_workers</li>
		<li>https://html.spec.whatwg.org/multipage/#toc-workers</li>
	</ul>
</div>
</details>

<details>
<summary>Является ли service workers частью спецификации HTML 5?</summary>
<div> <br />
	<p>Service worker запускается в контексте worker'ов, поэтому он не имеет доступа к DOM и работает в потоке отдельном от основного потока JavaScript, управляющего вашим приложением, а следовательно — не блокирует его. Он призван быть полностью асинхронным; как следствие, синхронные API, такие как XHR и localStorage, в service worker'е использовать нельзя.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API</li>
		<li>https://html.spec.whatwg.org/multipage/#toc-workers</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое гиперссылка?</summary>
<div> <br />
	<p>Часть гипертекстового документа, ссылающаяся на другой элемент (команда, текст, заголовок, примечание, изображение) в самом документе, на другой объект (файл, каталог, приложение), расположенный на локальном диске или в компьютерной сети, либо на элементы этого объекта.</p>
	<p>
		Подробней: https://ru.wikipedia.org/wiki/Гиперссылка
	</p>
</div>
</details>

<details>
<summary>Что такое GraphQL?</summary>
<div> <br />
	<p>В двух словах, GraphQL это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом для загрузки данных с сервера. GraphQL имеет три основные характеристики:</p>
	<ul>
		<li>Позволяет клиенту точно указать, какие данные ему нужны.</li>
		<li>Облегчает агрегацию данных из нескольких источников.</li>
		<li>Использует систему типов для описания данных.</li>
	</ul>
	<p>
		Подробней: https://habrahabr.ru/post/326986/
	</p>
</div>
</details>

<details>
<summary>Что такое HTTP?</summary>
<div> <br />
	<p>Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение, создаёт запрос, а затем ждет ответа. HTTP - это stateless-протокол, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он так же может использовать любой транспорт, который не теряет молча сообщения (то есть он обязан знать дошло ли сообщение до адресата).</p>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/HTTP</li>
		<li>https://ru.wikipedia.org/wiki/HTTP</li>
		<li>https://habrahabr.ru/post/215117/</li>
	</ul>
</div>
</details>

<details>
<summary>Если через консоль, примеру curl'oм, запросить сайт, что мы увидим?</summary>
<div> <br />
	<p>Стандартный ответ страницы, как для браузера</p>
	<p>Еще желательно знать, как организовывается докачка файлов, после восстановления соединения.</p>
	<p>
		Подробней: https://ru.wikipedia.org/wiki/HTTP
	</p>
</div>
</details>

<details>
<summary>Перечислите хотя бы 4 метода HTTP:</summary>
<div> <br />
	<p>GET, POST, PUT, DELETE</p>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/HTTP</li>
		<li>https://ru.wikipedia.org/wiki/HTTP</li>
	</ul>
</div>
</details>

<details>
<summary>Назовите 5 классов ошибок при HTTP запросе:</summary>
<div> <br />
	<ul>
		<li>1xx Информирование о процессе передачи.</li>
		<li>2xx Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</li>
		<li>3xx Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.</li>
		<li>4xx Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</li>
		<li>5xx Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</li>
	</ul>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/HTTP</li>
		<li>https://ru.wikipedia.org/wiki/HTTP</li>
	</ul>
</div>
</details>

<details>
<summary>В чем отличия HTTP/1 от HTTP/2?</summary>
<div> <br />
	<p>Протокол HTTP/2 является бинарным. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом.</p>
	<p>В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений.</p>
	<p>Также часть улучшений получена за счёт мультиплексирования запросов и ответов для преодоления проблемы «head-of-line blocking» протоколов HTTP 1; сжатия передаваемых заголовков и введения явной приоритезации запросов.</p>
	<p>Так же поддерживает приоритетность загрузки</p>
	<p>
		Подробней: https://ru.wikipedia.org/wiki/HTTP/2
	</p>
</div>
</details>

<details>
<summary>Где именно хранятся данные session и как сервер понимает как сопоставить конкретные данные session конкретному http запросу?</summary>
<div>
	<br />
	<p>Сессии могут храниться на клиенте (signed cookie session). При этом используется подпись куки с помощью HMAC, чтобы данные сессии не могли быть свободно изменены клиентом. Но обычно сессии хранятся на сервере. Тут выбор огромный: от баз данных и key-value хранилищ (Redis, например) до простых файлов. При этом, клиенту посылается кука ID сессии (так сервер идентифицирует юзера), которую злоумышленник может стащить. Таким кукам, дабы защитить юзеров от XSS, ставится флаг HttpOnly, который советует браузеру не давать эту куку скриптам вроде JS. В этом случае, стащить куку получится только завладев браузером, файловой системой юзера или через багу браузера.</p>
	<p>Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки</p>
</div>
</details>

<details>
<summary>Что такое HTTPS?</summary>
<div>
	<br />
	<p>HTTPS (HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443</p>
	<b>Подробней:</b>
	<ul>
		<li>https://yandex.ru/blog/company/77455</li>
		<li>https://ru.wikipedia.org/wiki/HTTPS</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое REST?</summary>
<div>
	<br />
	<p>REST API — это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.

Термин состоит из двух аббревиатур, которые расшифровываются следующим образом. API (Application Programming Interface) — это код, который позволяет двум приложениям обмениваться данными с сервера. На русском языке его принято называть программным интерфейсом приложения. REST (Representational State Transfer) — это способ создания API с помощью протокола HTTP. На русском его называют «передачей состояния представления».

Технологию REST API применяют везде, где пользователю сайта или веб-приложения нужно предоставить данные с сервера. Например, при нажатии иконки с видео на видеохостинге REST API проводит операции и запускает ролик с сервера в браузере. В настоящее время это самый распространенный способ организации API. Он вытеснил ранее популярные способы SOAP и WSDL.

У RESTful нет единого стандарта работы: его называют «архитектурным стилем» для операций по работе с серверов. Такой подход в 2000 году в своей диссертации ввел программист и исследователь Рой Филдинг, один из создателей протокола HTTP.</p>

<p>REST (Representational State Transfer) - это веб-сервисы, которые позволяют отправлять запросы к ресурсам по URL-путям. Указывается операция, которую необходимо выполнить, с помощью пути (например, GET, CREATE, DELETE).</p>
Принципы REST API

У RESTful есть 7 принципов написания кода интерфейсов.

Отделения клиента от сервера (Client-Server). Клиент — это пользовательский интерфейс сайта или приложения, например, поисковая строка видеохостинга. В REST API код запросов остается на стороне клиента, а код для доступа к данным — на стороне сервера. Это упрощает организацию API, позволяет легко переносить пользовательский интерфейс на другую платформу и дает возможность лучше масштабировать серверное хранение данных.

Отсутствие записи состояния клиента (Stateless). Сервер не должен хранить информацию о состоянии (проведенных операций) клиента. Каждый запрос от клиента должен содержать только ту информацию, которая нужна для получения данных от сервера.

Кэшируемость (Casheable). В данных запроса должно быть указано, нужно ли кэшировать данные (сохранять в специальном буфере для частых запросов). Если такое указание есть, клиент получит право обращаться к этому буферу при необходимости.

Единство интерфейса (Uniform Interface). Все данные должны запрашиваться через один URL-адрес стандартными протоколами, например, HTTP. Это упрощает архитектуру сайта или приложения и делает взаимодействие с сервером понятнее.

Многоуровневость системы (Layered System). В RESTful сервера могут располагаться на разных уровнях, при этом каждый сервер взаимодействует только с ближайшими уровнями и не связан запросами с другими.

Предоставление кода по запросу (Code on Demand). Серверы могут отправлять клиенту код (например, скрипт для запуска видео). Так общий код приложения или сайта становится сложнее только при необходимости.

Начало от нуля (Starting with the Null Style). Клиент знает только одну точку входа на сервер. Дальнейшие возможности по взаимодействию обеспечиваются сервером
<b>Подробней:</b>

<ul>
<li>https://ru.wikipedia.org/wiki/REST</li>
<li>https://habrahabr.ru/post/38730/</li>
</ul>

</div>
</details>

<details>
<summary>Что такое протокол-SOAP?</summary>
<div>
	<br />
	<p>SOAP (Simple Object Access Protocol — простой протокол доступа к объектам) — протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. Официальная спецификация последней версии 1.2 протокола никак не расшифровывает название SOAP. SOAP является расширением протокола XML-RPC.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://ru.wikipedia.org/wiki/SOAP</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое нотация О-большое?</summary>
<div>
	<br />
	<p>В информатике временна́я сложность алгоритма определяет время работы, используемое алгоритмом, как функции от длины строки, представляющей входные данные. Временная сложность алгоритма обычно выражается с использованием нотации «O» большое, которая исключает коэффициенты и члены меньшего порядка. Если сложность выражена таким способом, говорят об асимптотическом описании временной сложности, т.е. при стремлении размера входа к бесконечности. Например, если время, которое нужно алгоритму для выполнения работы, для всех входов длины n не превосходит 5n3 + 3n для некоторого n (большего некоторого n0), асимптотическая временная сложность равна O (n3).</p>
	<b>Подробней:</b>
	<ul>
		<li>https://ru.wikipedia.org/wiki/Временная_сложность_алгоритма</li>
		<li>https://habrahabr.ru/post/195482/</li>
		<li>https://habrahabr.ru/post/188010/</li>
	</ul>
</div>
</details>

<details>
<summary>Опишите несколько способов коммуникаций между серверов и клиентом. Опишите работу нескольких сетевых протоколов на высоком уровне(IP, TCP, HTTP/S/2, UDP, RTC, DNS, etc.).\*</summary>
<div>
	<br />
</div>
</details>

<details>
<summary>Что такое HMAC?</summary>
<div> <br />
	<p>HMAC (сокращение от англ. hash-based message authentication code, код аутентификации (проверки подлинности) сообщений, использующий хеш-функции) — в информатике (криптографии), один из механизмов проверки целостности информации, позволяющий гарантировать то, что данные, передаваемые или хранящиеся в ненадёжной среде, не были изменены посторонними лицами (см. человек посередине). Механизм HMAC использует MAC, описан в RFC 2104, в стандартах организаций ANSI, IETF, ISO и NIST. MAC — стандарт, описывающий способ обмена данными и способ проверки целостности передаваемых данных с использованием секретного ключа. Два клиента, использующие HMAC, как правило, разделяют общий секретный ключ. HMAC — надстройка над MAC; механизм обмена данными с использованием секретного ключа (как в MAC) и хеш-функций. В зависимости от используемой хеш-функции выделяют HMAC-MD5, HMAC-SHA1, HMAC-RIPEMD128, HMAC-RIPEMD160 и т. п.</p>
	<p>
		Подробней: https://ru.wikipedia.org/wiki/HMAC
	</p>
</div>
</details>

<details>
<summary>Что такое CORS?</summary>
<div>
	<br />
	<p>CORS (Cross-Origin Resource Sharing,"Совместное использование ресурсов между разными источниками") - это система, состоящая из отправки HTTP заголовков, которые определяют: заблокировать или выполнить запрос к ограниченному ресурсу на веб-странице из другого домена, отличного от домена происхождения запрашиваемого ресурса.</p>
	<p>The same-origin security policy ("правило ограничения домена") по умолчанию запрещает междоменные запросы. CORS предоставляет веб-серверам возможность контролировать междоменные запросы и позволяет производить безопасный обмен данными между разными доменами.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Словарь/CORS</li>
		<li>https://habrahabr.ru/company/pentestit/blog/337146/</li>
		<li>https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое архитектурный-паттерн MVC?</summary>
<div>
	<br />
	<p>Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо</p>
	<ul>
		<li><b>Модель</b> (Model) предоставляет данные и реагирует на команды контроллера, изменяя свое состояние.</li>
		<li><b>Представление</b> (View) отвечает за отображение данных модели пользователю, реагируя на изменения модель.</li>
		<li><b>Контроллер</b> (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений.</li>
	</ul>
	<p>Есть passive model & active model. Но из-за веба, этот паттер, претерпел изменения, что вносит смуту, и вряд ли получится найти 3 программиста, у которых совпадет понимание этого паттерна. Главное понимать общие черты, чтобы суметь отличить от MVVM(bindings) ;)</p>
	<b>Признаки контроллера:</b>
	<br />
	<ul>
		<li>Контроллер определяет, какие представление должно быть отображено в данный момент;</li>
		<li>События представления могут повлиять только на контроллер.контроллер может повлиять на модель и определить другое представление.</li>
		<li>Возможно несколько представлений только для одного контроллера;</li>
	</ul>
	<b>Подробней:</b>
	<ul>
		<li>https://codepen.io/fikorte/pen/Rjgmqr?limit=all&page=2&q=mvc+example</li>
		<li>https://codepen.io/broneks/pen/RWRLRG?editors=1010</li>
		<li>https://codepen.io/kyliepace/pen/aNepxV?editors=1010</li>
		<li>https://codepen.io/bobodeity/pen/xPbwzX</li>
		<li>https://habrahabr.ru/company/devexpress/blog/305812/</li>
		<li>https://codepen.io/MrCheater/pen/GqQpYY?editors=1010</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое архитектурный-паттерн MVP?</summary>
<div>
	<br />
	<p>Данный подход позволяет создавать абстракцию представления. Для этого необходимо выделить интерфейс представления с определенным набором свойств и методов. Презентер, в свою очередь, получает ссылку на реализацию интерфейса, подписывается на события представления и по запросу изменяет модель.</p>
	<b>Признаки презентера:</b>
	<br />
	<ul>
		<li>Двухсторонняя коммуникация с представлением;</li>
		<li>Представление взаимодействует напрямую с презентером, путем вызова соответствующих функций или событий экземпляра презентера;</li>
		<li>Презентер взаимодействует с View путем использования специального интерфейса, реализованного представлением;</li>
		<li>Один экземпляр презентера связан с одним отображением.</li>
	</ul>
	<b>Подробеней:</b>
	<br />
	<p>https://habrahabr.ru/post/215605/</p>
	<p>https://stackoverflow.com/questions/2056/what-are-mvp-and-mvc-and-what-is-the-difference</p>
	<p>https://habrahabr.ru/post/171925/</p>
	<p>https://habrahabr.ru/company/mobileup/blog/313538/</p>
</div>
</details>

<details>
<summary>Что такое архитектурный-паттерн MVVM?</summary>
<div>
	<br />
	<p>Данный подход позволяет связывать элементы представления со свойствами и событиями View-модели. Можно утверждать, что каждый слой этого паттерна не знает о существовании другого слоя.</p>
	<b>Признаки презентера:</b>
	<br />
	<ul>
		<li>Двухсторонняя коммуникация с представлением;</li>
		<li>View-модель — это абстракция представления. Обычно означает, что свойства представления совпадают со свойствами View-модели / модели</li>
		<li>View-модель не имеет ссылки на интерфейс представления (IView). Изменение состояния View-модели автоматически изменяет представление и наоборот, поскольку используется механизм связывания данных (Bindings)</li>
		<li>Один экземпляр View-модели связан с одним отображением.</li>
	</ul>
	<b>Подробней:</b>
	<br />
	<p>https://habrahabr.ru/post/215605/</p>
	<p>https://ru.wikipedia.org/wiki/Model-View-ViewModel</p>
	<p>https://habrahabr.ru/company/mobileup/blog/313538/</p>
</div>
</details>

<details>
<summary>Что такое DCI?</summary>
<div>
	<br />
	<p>https://habrahabr.ru/post/151169/</p>
</div>
</details>

<details>
<summary>Что такое DOM?</summary>
<div>
	<br />
	<p>Объектная Модель Документа (DOM) является программным интерфейсом для HTML, XML и SVG документов. Это обеспечивает структурированное представление документа (дерева), и определяет способ, по которому структура может быть доступна для программы, для изменения структуры документа, его стиля и содержания. DOM обеспечивает представление документа в виде структурированной группы узлов и объектов, которые имеют свойства и методы. По сути, она связывает веб -страницы со скриптами или языками программирования.</p>
	<p>DOM (Document Object Model — «объектная модель документа») — это независящий от платформы и языка программный интерфейс, позволяющий программам и скриптам получить доступ к содержимому HTML-, XHTML- и XML-документов, а также изменять содержимое, структуру и оформление таких документов.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/DOM/DOM_Reference</li>
		<li>https://ru.wikipedia.org/wiki/Document_Object_Model</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое Virtual DOM? Как он работает?</summary>
<div>
	<br />
	<p>Virtual DOM - это абстракция HTML DOM, которая выборочно отображает поддеревья узлов на основе изменений состояния. Он обеспечивает минимальное количество манипуляций с DOM, чтобы поддерживать ваши компоненты в актуальном состоянии.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://medium.com/treenodes/intro-to-react-2-41b84dd74b5d</li>
		<li>https://habrahabr.ru/post/256965/</li>
		<li>https://medium.com/devschacht/how-to-write-your-own-virtual-dom-c166b56cf01f</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое Shadow DOM?</summary>
<div>
	<br />
	<p>Спецификация Shadow DOM является отдельным стандартом. Частично он уже используется для обычных DOM-элементов, но также применяется для создания веб-компонентов.</p>
	<p>Shadow DOM – это внутренний DOM элемента, который существует отдельно от внешнего документа. В нём могут быть свои ID, свои стили и так далее. Причём снаружи его, без применения специальных техник, не видно, поэтому не возникает конфликтов.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://learn.javascript.ru/shadow-dom</li>
		<li>https://habrahabr.ru/post/180377/</li>
		<li>https://habrahabr.ru/post/259187/</li>
		<li>https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM</li>
	</ul>
</div>
</details>

<details>
<summary>Чем отличаются между собой Shadow DOM и Virtual DOM и Regular Dom?</summary>
<div>
	<br />
	<p>Virtual DOM – полное представление реального DOM. Его самой важной особенностью является группировка изменений и выполнение одиночного повторного рендеринга вместо множества мелких. Если коротко, то можно сказать, что Virtual DOM решает проблемы, связанные с производительностью (Не буду вдаваться в подробности принципа работы Virtual DOM. В рамках этой статьи достаточно знать, зачем он нужен.)</p>
	<p>Shadow DOM, как настоящий интроверт, надежно защищает себя от влияния окружающих элементов и не заинтересован и не интересуется изменениями снаружи. Спросите себя, какую главную UI-проблему решают фреймворки типа React и VueJS?</p>
	<p><b>Инкапсуляция</b></p>
	<p>CSS – сложная штука. Все становится еще сложнее, если вы соединяете стили, пытаясь повторно их использовать в различных комбинациях. Это неизбежно приводит к регрессивным ошибкам интерфейса, сложному обслуживанию и плохой масштабируемости. И все же, я считаю, что основная проблема это не CSS, а то, как мы его используем.</p>
	<p>Shadow DOM – инструмент, помогающий обойти инкапсуляцию DOM на нативном уровне. Суть не просто в CSS, а в элементах.</p>
	<p>В отличие от обычного DOM Shadow DOM идет маленькими кусочками. То есть это не полное представление всего DOM. Представьте Shadow DOM в виде лего, формирующего реальный DOM, где каждый кирпичик представляет собой отдельный DOM.</p>
	<p>Shadow DOM – это инкапсуляция.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://develoger.com/shadow-dom-virtual-dom-889bf78ce701</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое ООП и на каких 4х постулатах оно стоит?</summary>
<div>
	<br />
	<p>абстрагирование для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, в конечном счете — контекстное понимание предмета, формализуемое в виде класса;</p>
	<p>инкапсуляция для быстрой и безопасной организации собственно иерархической управляемости: чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, так как это уже другой уровень управления;</p>
	<p>наследование для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом шаге учитывать только изменения, не дублируя все остальное, учтенное на предыдущих шагах;</p>
	<p>полиморфизм для определения точки, в которой единое управление лучше распараллелить или наоборот — собрать воедино.</p>
	<p>Подробней: https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование</p>
</div>
</details>

<details>
<summary>Что такое инкапсуляция?</summary>
<div>
	<br />
	<p>Инкапсуляция - это механизм, который объединяет данные и методы, манипулирующие этими данными, и защищает и то и другое от внешнего вмешательства или неправильного использования. Когда методы и данные объединяются таким способом, создается объект.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://ru.wikipedia.org/wiki/Инкапсуляция_(программирование)</li>
		<li>https://habrahabr.ru/post/87205/</li>
	</ul>
</div>
</details>

<details>
<summary>Какие классификации паттернов проектирования Вы знаете?</summary>
<div>
	<br />
	<p><b>Порождающие паттерны</b> беспокоятся о гибком создании объектов без внесения в программу лишних зависимостей.</p>
	<p><b>Структурные паттерны</b> показывают различные способы построения связей между объектами.</p>
	<p><b>Поведенческие паттерны</b> заботятся об эффективной коммуникации между объектами.</p>
	<b>Подробней:</b>
	<ul>
		<li>https://refactoring.guru/ru/design-patterns/classification</li>
		<li>https://ru.wikipedia.org/wiki/Шаблон_проектирования</li>
	</ul>
</div>
</details>

<details>
<summary>Назовите паттерны, которые относятся к порождающим</summary>
<div>
	<br />
	<ul>
		<li>
			<b>Одиночка(Singleton)</b>:
			<br />
			<p>Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.</p>
			<p>https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/singleton</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/singleton</p>
		</li>
		<li>
			<b>Абстрактная фабрика(Abstract factory)</b>
			<br />
			<p>Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.</p>
			<p>https://ru.wikipedia.org/wiki/Абстрактная_фабрика_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/abstract-factory</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/abstract_factory</p>
		</li>
		<li>
			<b>Фабричный метод(Factory method)</b>
			<br />
			<p>Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.</p>
			<p>https://ru.wikipedia.org/wiki/Фабричный_метод_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/factory-method</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/factory_method</p>
		</li>
		<li>
			<b>Строитель(Builder)</b>
			<br />
			<p>Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.</p>
			<p>https://ru.wikipedia.org/wiki/Строитель_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/builder</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/builder</p>
		</li>
		<li>
			<b>Прототип(Prototype)</b>
			<br />
			<p>Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.</p>
			<p>https://ru.wikipedia.org/wiki/Прототип_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/prototype</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/prototype</p>
		</li>
		<li>
			<b>Менее известные:</b>
			<ul>
				<li>
					<b>Отложенная инициализация(Lazy initialization)</b>
					<br />
					<p>Объект, инициализируемый во время первого обращения к нему.</p>
					<p>https://ru.wikipedia.org/wiki/Отложенная_инициализация</p>
				</li>
				<li>
					<b>Пул одиночек(Multiton)</b>
					<br />
					<p>Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним.</p>
					<p>https://ru.wikipedia.org/wiki/Объектный_пул</p>
				</li>
				<li>
					<b>Получение ресурса есть инициализация(Resource acquisition is initialization (RAII))</b>
					<br />
					<p>Получение некоторого ресурса совмещается с инициализацией, а освобождение — с уничтожением объекта.</p>
					<p>https://ru.wikipedia.org/wiki/Получение_ресурса_есть_инициализация</p>
				</li>
			</ul>
		</li>
	</ul>
</div>
</details>

<details>
<summary>Назовите паттерны, которые относятся к структурным</summary>
<div>
	<br />
	<ul>
		<li>
			<b>Адаптер(Adapter / Wrapper)</b>
			<br />
			<p>Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.</p>
			<p>https://ru.wikipedia.org/wiki/Адаптер_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/adapter</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/adapter</p>
		</li>
		<li>
			<b>Мост(Bridge)</b>
			<br />
			<p>Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.</p>
			<p>https://ru.wikipedia.org/wiki/Мост_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/bridge</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/bridge</p>
		</li>
		<li>
			<b>Компоновщик(Composite)</b>
			<br />
			<p>Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидную структуру, а затем работать с ними так, если бы это был единичный объект.</p>
			<p>https://ru.wikipedia.org/wiki/Composite</p>
			<p>https://refactoring.guru/ru/design-patterns/composite</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/composite</p>
		</li>
		<li>
			<b>Декоратор(Decorator)</b>
			<br />
			<p>Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».</p>
			<p>https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/decorator</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/decorator</p>
		</li>
		<li>
			<b>Фасад(Facade)</b>
			<br />
			<p>Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.</p>
			<p>https://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/facade</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/facade</p>
		</li>
		<li>
			<b>Приспособленец(Flyweight) или Легковес</b>
			<br />
			<p>Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативной память за счёт экономного разделения общего состояния объектов между собой, вместо хранения одинаковых данных в каждом объекте.</p>
			<p>https://ru.wikipedia.org/wiki/Flyweight</p>
			<p>https://refactoring.guru/ru/design-patterns/flyweight</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/flyweight</p>
		</li>
		<li>
			<b>Заместитель(Proxy)</b>
			<br />
			<p>Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.</p>
			<p>https://ru.wikipedia.org/wiki/Proxy_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/proxy</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/proxy</p>
		</li>
		<li>
			<b>Менее известные:</b>
			<ul>
				<li>
					<b>Единая точка входа(Front controller)</b>
					<br />
					<p>Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.</p>
					<p>https://ru.wikipedia.org/wiki/Единая_точка_входа_(шаблон_проектирования)</p>
				</li>
			</ul>
		</li>
	</ul>
</div>
</details>

<details>
<summary>Назовите паттерны, которые относятся к поведенческим</summary>
<div>
	<br />
	<ul>
		<li>
			<b>Цепочка обязанностей(Chain of responsibility)</b>
			<br />
			<p>Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.</p>
			<p>https://ru.wikipedia.org/wiki/Chain_of_Responsibility</p>
			<p>https://refactoring.guru/ru/design-patterns/chain-of-responsibility</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/chain_of_responsibility</p>
		</li>
		<li>
			<b>Команда, Action, Transaction(Command)</b>
			<br />
			<p>Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.</p>
			<p>https://ru.wikipedia.org/wiki/Команда_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/command</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/command</p>
		</li>
		<li>
			<b>Интерпретатор(Interpreter)</b>
			<br />
			<p>Решает часто встречающуюся, но подверженную изменениям, задачу.</p>
			<p>https://ru.wikipedia.org/wiki/Интерпретатор_(шаблон_проектирования)</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/interpreter</p>
		</li>
		<li>
			<p>Итератор, Cursor(Iterator)</p>
			<br />
			<p>Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.</p>
			<p>https://ru.wikipedia.org/wiki/Итератор_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/iterator</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/iterator</p>
		</li>
		<li>
			<b>Посредник(Mediator)</b>
			<br />
			<p>Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.</p>
			<p>https://ru.wikipedia.org/wiki/Mediator</p>
			<p>https://refactoring.guru/ru/design-patterns/mediator</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/mediator</p>
		</li>
		<li>
			<b>Хранитель(Memento)</b>
			<br />
			<p>Снимок — это поведенческий паттерн проектирования, который позволяет делать снимки состояния объектов, не раскрывая подробностей их реализации. Затем снимки можно использовать, чтобы восстановить прошлое состояние объектов.</p>
			<p>https://ru.wikipedia.org/wiki/Хранитель_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/memento</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/memento</p>
		</li>
		<li>
			<b>Наблюдатель(Observer)</b>
			<br />
			<p>Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.</p>
			<p>https://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/observer</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/observer</p>
			<p>https://ru.wikipedia.org/wiki/Издатель-подписчик_(шаблон_проектирования)</p>
		</li>
		<li>
			<b>Состояние(State)</b>
			<br />
			<p>Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.</p>
			<p>https://ru.wikipedia.org/wiki/Состояние_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/state</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/state</p>
		</li>
		<li>
			<b>Стратегия(Strategy)</b>
			<br />
			<p>Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс. После чего, алгоритмы можно взаимозаменять прямо во время исполнения программы.</p>
			<p>https://ru.wikipedia.org/wiki/Стратегия_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/strategy</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/strategy</p>
		</li>
		<li>
			<b>Шаблонный метод(Template method)</b>
			<br />
			<p>Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.</p>
			<p>https://ru.wikipedia.org/wiki/Шаблонный_метод_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/template-method</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/template_method</p>
		</li>
		<li>
			<b>Посетитель(Visitor)</b>
			<br />
			<p>Посетитель — это поведенческий паттерн проектирования, который позволяет создавать новые операции, не меняя классы объектов, над которыми эти операции могут выполняться.</p>
			<p>https://ru.wikipedia.org/wiki/Посетитель_(шаблон_проектирования)</p>
			<p>https://refactoring.guru/ru/design-patterns/visitor</p>
			<p>https://github.com/torokmark/design_patterns_in_typescript/tree/master/visitor</p>
		</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое функциональное программирование?</summary>
<div>
	<br />
	<p>Функциона́льное программи́рование — раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).</p>
	<p>Противопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список.</p>
	<p>Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного, где одной из базовых концепций является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма).</p>
	<b>Подробней:</b>
	<ul>
		<li>https://ru.wikipedia.org/wiki/Функциональное_программирование</li>
		<li>https://habrahabr.ru/post/142351/</li>
		<li>https://ru.stackoverflow.com/questions/417898/Что-такое-функциональное-программирование</li>
		<li>https://tproger.ru/translations/functional-programming-concepts/</li>
		<li>https://habrahabr.ru/post/337880/</li>
	</ul>
</div>
</details>

## Вопросы по HTML:

<details>
<summary>Для чего нужен doctype и сколько разновидностей Вы можете назвать?</summary>
<div> <br />
	<p>Элемент DOCTYPE предназначен для указания типа текущего документа — DTD (document type definition, описание типа документа). Это необходимо, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, поскольку HTML существует в нескольких версиях, кроме того, имеется XHTML (EXtensible HyperText Markup Language, расширенный язык разметки гипертекста), похожий на HTML, но различающийся с ним по синтаксису. Чтобы браузер «не путался» и понимал, согласно какому стандарту отображать веб-страницу и необходимо в первой строке кода задавать DOCTYPE.</p>
	<ul>
		<li>HTML 4.01</li>
		<li>HTML 5</li>
		<li>XHTML 1.0</li>
		<li>XHTML 1.1</li>
	</ul>
	<ul>
		<li>Подробней про то, как указывать теги для определенного Doctype: http://htmlbook.ru/html/%21doctype</li>
		<li>Хорошая полезная подробная статья: https://habrahabr.ru/post/71364/</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое режим совместимости (Quirks Mode) и стандартный режим (Standards Mode)</summary>
<div> <br />
	<p>На сегодняшний день существует три режима отображения, которые используются движками разметки (layout engines) браузеров: режим совместимости (quirks mode), частично стандартный режим (almost standards mode) и стандартный режим (full standards mode). В режиме совместимости (quirks mode), разметка эмулирует нестандартное поведение браузеров Navigator 4 и Internet Explorer 5. Этот режим необходим для поддержки сайтов, созданных до начала широкого применения веб стандартов. В стандартном режиме (full standards mode) поведение браузера соответствует (будем надеяться) описанному в спецификациях HTML и CSS. В частично стандартном режиме (almost standards mode)  реализовано лишь незначительное количество так называемых "странностей" (quirks).</p>
	<p>Если вы будете пользоваться неполным тегом DOCTYPE, устаревшим его видом, или вообще забудете про него, броузер перейдет в «загадочный» (quirk) режим и будет исходить из предположения, что вы писали код страницы с ошибками и вольно отступали от стандартов, т.е. так, как писали в конце 90-ых годов.  В этом режиме броузер попытается разобрать вашу страницу по правилам обратной совместимости и выведет на экран, например, CSS так, как его вывел бы Internet Explorer 4-ой версии, а DOM будет работать так, как он работал именно в этом броузере (IE переключается в свой старый DOM, а Mozilla и Netscape 6 переключается вообще в бог знает что).</p>
	<b>Подробней</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Quirks_Mode_and_Standards_Mode</li>
		<li>https://habrahabr.ru/post/71364/</li>
	</ul>
</div>
</details>

<details>
<summary>В чем разница между HTML и XHTML?</summary>
<div> <br />
	<ul>
		<li>XHTML - это приложение XML, которое является довольно строгим языком с угловыми скобками.</li>
		<li>HTML - это приложение SGML, которое является гораздо менее строгим языком с угловой скобкой.</li>
		<li>(XML также является применением SGML.)</li>
	</ul>
	<p>При написании кода XHTML придерживаются того же синтаксиса, который характерен для HTML. При этом разница между HTML и XHTML состоит в наборе некоторых обязательных правил.</p>
	<b>Правила XHTML следующие.</b>
	<ul>
		<li>Все теги и их атрибуты должны быть набраны в нижнем регистре (строчными символами).</li>
		<li>Значения любых атрибутов необходимо заключать в кавычки.</li>
		<li>Требуется закрывать все теги, даже такие, которым не сопоставлен закрывающий тег.</li>
		<li>Должна соблюдаться правильная вложенность тегов.</li>
		<li>Нельзя использовать сокращенные атрибуты тегов.</li>
		<li>Вместо атрибута name следует указывать id.</li>
		<li>Следует определять DTD (document type definition, описание типа документа) с помощью элемента DOCTYPE.</li>
	</ul>
	<p>
		Подробнее с примерами: http://htmlbook.ru/xhtml/sintaksis-xhtml
	</p>
</div>
</details>

<details>
<summary>Могут ли возникнуть проблемы при подаче страниц с типом application/xhtml+xml?</summary>
<div> <br />
<p>MIME (Multipurpose Internet Mail Extensions, многоцелевые расширения интернет-почты) — стандарт Интернет, является частью протокола HTTP. Задача MIME это идентификация типа содержимого документа по его заголовку. К примеру, текстовый файл имеет тип text/plain, а HTML-файл — text/html. Отправка заголовка обычно происходит на основе расширения файла веб-сервером.</p>
<p>Документы XHTML по умолчанию отправляются как text/html, что в действительности говорит о том, что мы имеем дело с HTML, а не XHTML-файлом. Чтобы задействовать возможности XHTML требуется отдавать файл с типом application/xhtml+xml. Если у вас установлен веб-сервер Apache, то вы можете сделать это через директиву AddType, добавив следующую строку в файл .htaccess, расположенный в корне сайта.</p>

`AddType application/xhtml+xml .xhtml`

<p>В данном случае мы говорим, что все файлы с расширением .xhtml отдавать как application/xhtml+xml. Если документы формируются через PHP, то можно отдавать заголовок следующим образом:</p>

`header ("Content-type: application/xhtml+xml");`

<p>Учтите, что эта строка должна идти до вывода любого текста на странице.</p>
<p>Браузер Internet Explorer до версии 8.0 включительно не поддерживает тип application/xhtml+xml и не сможет отобразить страницу, которая отдаётся с этим типом. Остальные браузеры, в том числе IE9, понимают этот тип как переход в стандартный режим.</p>
<p>Тип application/xhtml+xml необходим в случае, когда в документе применяется MathML (Mathematical Markup Language, язык математической разметки), предназначенный для добавления формул или SVG (Scalable Vector Graphics, масштабируемая векторная графика), язык разметки для создания на странице векторных рисунков. Если вы ничего не знаете об этих технологиях и пока не собираетесь их использовать, лучше отдавать документ как text/html. Это позволит охватить наибольшее количество браузеров и поисковых систем.</p>
<p>По сути, тип text/html для файлов с расширением .html или .htm настроен автоматически, поэтому не требуется предпринимать каких-либо действий для этого типа.</p>
<p>согласование содержимого для переключения между application/xhtml+xml и text/html так же, как вы описываете, не замечая проблем с поисковыми роботами. Строго говоря, вы должны учитывать значения q в заголовке accept, который указывает предпочтение пользовательского агента к каждому типу контента. Если пользовательский агент предпочитает принимать text/html, но будет принимать application/xhtml+xml в качестве альтернативы, то для обеспечения максимальной безопасности вы должны иметь страницу text/html.</p>
</div>
</details>

<details>
<summary>Какая связь между SGML, HTML, XML и XHTML?</summary>
<div> <br />
	<p>SGML (Standard generalized markup language — стандартный обобщённый язык разметки) – это стандарт, который определяет разметку документа.</p>
	<p>HTML – это язык разметки, который описывается с помощью SGML.</p>
	<p>Итак, с помощью SGML было создано DTD (определение типа документа), на которое ссылается и которого должен придерживаться HTML. Поэтому вы всегда можете найти декларацию «DOCTYPE» в начале страницы HTML, которая определяет, какое DTD будет использовать браузер при разборе кода страницы.</p>

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
```

<p>Разбор кода по стандарту SGML был связан с определёнными трудностями, поэтому был создан XML, чтобы облегчить эту процедуру. XML использует SGML. Например, в SGML вы должны использовать открывающие и закрывающие теги, тогда как в XML вы можете использовать самозакрывающиеся теги, которые закрываются автоматически. XHML был создан из XML и использовался в HTML 4.0. Поэтому, например, в HTML, основанном на SGML, тег недопустим, а в XHTML он допускается. Вы можете использовать XML определение документа, как показано в следующем примере:</p>

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
```

<p>Вкратце, SGML стоит в основе всего. Старые версии HTML основаны на SGML, а HTML 4.0 использует XHTML, построенный на основе XML.</p>
</div>
</details>

<details>
<summary>Как следует оформлять страницу, в которой контент может быть на разных языках?</summary>
<div> <br />
	<p>От гугла: https://support.google.com/webmasters/answer/182192?hl=ru</p>
</div>
</details>

<details>
<summary>Чем полезны data- атрибуты?</summary>
<div> <br />
	<p>HTML5 спроектирован с возможностью расширения данных ассоциированных с каким-либо элементом, но в то же время не обязательно имеющих определённое значение. data-* атрибуты позволяют хранить дополнительную информацию в стандартных элементах HTML, без хаков вроде нестандартных атрибутов, лишних DOM-свойств или Node.setUserData().</p>
	<b>Синтаксис HTML</b>

```html
<article
  id="electriccars"
  data-columns="3"
  data-index-number="12314"
  data-parent="cars"
></article>
```

<b>Доступ в JavaScript</b>

```javascript
var article = document.getElementById("electriccars");
article.dataset.columns; // "3"
article.dataset.indexNumber; // "12314"
article.dataset.parent; // "cars"
```

<b>Доступ в CSS</b>

```css
article::before {
  content: attr(data-parent);
}
```

<p>
	Подробнее: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Using_data_attributes
</p>
</div>
</details>

<details>
<summary>Если рассматривать HTML5 как открытую web-платформу, на чем она строится, из каких компонентов состоит?</summary>
<div> <br />
	<p>HTML5 (англ. HyperText Markup Language, version 5) — язык для структурирования и представления содержимого всемирной паутины. Это пятая версия HTML. Хотя стандарт был завершён (рекомендованная версия к использованию) только в 2014 году (предыдущая, четвёртая, версия опубликована в 1999 году), ещё с 2013 года[4] браузерами оперативно осуществлялась поддержка, а разработчиками — использование рабочего стандарта (англ. HTML Living Standard). Цель разработки HTML5 — улучшение уровня поддержки мультимедиа-технологий с одновременным сохранением обратной совместимости, удобочитаемости кода для человека и простоты анализа для парсеров.</p>
	<p>Во всемирной паутине долгое время использовались стандарты HTML 4.01, XHTML 1.0 и XHTML 1.1. Веб-страницы на практике оказывались свёрстаны с использованием смеси особенностей, представленных различными спецификациями, включая спецификации программных продуктов, например веб-браузеров, а также сложившихся общеупотребительных приёмов. HTML5 был создан как единый язык разметки, который мог бы сочетать синтаксические нормы HTML и XHTML. Он расширяет, улучшает и рационализирует разметку документов, а также добавляет единый API для сложных веб-приложений.</p>
	<p>В HTML5 реализовано множество новых синтаксических особенностей. Например, элементы <b>video</b>, <b>audio</b> и <b>canvas</b>, а также возможность использования SVG и математических формул. Эти новшества разработаны для упрощения создания и управления графическими и мультимедийными объектами в сети без необходимости использования сторонних API и плагинов. Другие новые элементы, такие как <b>section</b>, <b>article</b>, <b>header</b> и <b>nav</b>, разработаны для того, чтобы обогащать семантическое содержимое документа (страницы). Новые атрибуты были введены с той же целью, хотя ряд элементов и атрибутов был удалён. Некоторые элементы, например a, menu и cite, были изменены, переопределены или стандартизированы. API и DOM стали основными частями спецификации HTML5. HTML5 также определяет некоторые особенности обработки ошибок вёрстки, поэтому синтаксические ошибки должны рассматриваться одинаково всеми совместимыми браузерами.</p>
	<p>
		Подробнее: https://ru.wikipedia.org/wiki/HTML5
	</p>
</div>
</details>

<details>
<summary>В чем отличия HTML5 от HTML4.01 и XHTML1.0</summary>
<div>
	<br />
	<p>Ниже представлен список отличий(не все):</p>
	<ul>
		<li>Изменён синтаксис</li>
		<li>Встраивание SVG и MathML в text/html</li>
		<li>Новые элементы:

`<article>, <aside>, <audio>, <canvas>, <command>, <datalist>, <details>, <embed>, <figcaption>, <figure>, <footer>, <header>, <hgroup>, <keygen>, <main>, <mark>, <meter>, <nav>, <output>, <progress>, <rp>, <rt>, <ruby>, <section>, <source>, <summary>, <time>, <video>, <wbr>`

</li>
	<li>Новые компоненты ввода:

`date/time, email, url, search, number, range, tel, color`

</li>
	<li>Новые атрибуты: charset (в <b>meta</b>), async (в script)</li>
	<li>Глобальные атрибуты, которые могут быть применены ко всем элементам: id, tabindex, hidden, data-* (пользовательские атрибуты данных)</li>
	<li>Элементы, которые будут исключены:

`<acronym>, <applet>, <basefont>, <big>, <center>, <dir>, <font>, <frame>, <frameset>, <isindex>, <noframes>, <strike>, <tt>`

</li>
	</ul>
	<p>
		Подробнее: https://ru.wikipedia.org/wiki/HTML5
	</p>
</div>
</details>

<details>
<summary>Что такое HTTP cookie?</summary>
<div>
	<br />
	<p>HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.</p>
	<p>Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок  Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP  Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать  ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту  оно отсылается.</p>
	<p>Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки</p>
</div>
</details>

<details>
<summary>Что такое Secure ("безопасные") и HttpOnly cookies?</summary>
<div>
	<br />
	<p>"Безопасные" (secure) cookie отсылаются на сервер только если запрос выполняется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в cookies, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 and Firefox 52, незащищенные сайты (http:) не могут создавать куки с флагом secure.</p>
	<p>Куки HTTPonly не доступны из JavaScript через свойства Document.cookie, и через XMLHttpRequest и Request API, что помогает избежать межсайтового скриптинга (XSS). Устанавливайте этот флаг для тех cookie, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг HttpOnly.</p>

`Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly`

<p>
	Подробней: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки
</p>
</div>
</details>

<details>
<summary>Объясните разницу между cookies, sessionStorage и localStorage.</summary>
<div>
	<br />
	<ul>
		<li> 
			<b>LocalStorage</b>
			<br />
			<b>Плюсы:</b>
			<ul>
				<li>Веб-хранилище можно рассматривать упрощенно как усовершенствование файлов cookie, обеспечивая гораздо большую емкость хранилища. Если вы посмотрите исходный код Mozilla, мы увидим, что 5120KB (5 МБ), равный 2,5 миллионам символов в Chrome), является размером хранилища по умолчанию для весь домен. Это дает вам значительно больше возможностей для работы, чем обычный cookie 4 КБ.</li>
				<li>Данные не отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - уменьшение количества трафика между клиентом и сервером.</li>
				<li>Данные, хранящиеся в localStorage, сохраняются до явного удаления. Сделанные изменения сохраняются и доступны для всех текущих и будущих посещений сайта.</li>
			</ul>
			<b>Минусы:</b>
			<ul>
				<li>Он работает в политике одного и того же происхождения. Таким образом, сохраненные данные будут доступны только в том же месте.</li>
			</ul>
		</li>
		<li>
			<b>Cookies</b>
			<br />
			<b>Плюсы:</b>
			<ul>
				<li>По сравнению с другими, ничего.</li>
			</ul>
			<b>Минусы:</b>
			<ul>
				<li>Предел 4Kб предназначен для всего файла cookie, включая имя, значение, дату истечения срока годности и т.д. Чтобы поддерживать большинство браузеров, держите имя менее 4000 байт и общий размер файла cookie под 4093 байтами.</li>
				<li>Данные отправляются обратно на сервер для каждого HTTP-запроса (HTML, изображения, JavaScript, CSS и т.д.) - увеличение количества трафика между клиентом и сервером.</li>
			</ul>
			<b>Обычно допустимы следующие действия:</b>
			<ul>
				<li>300 файлов cookie</li>
				<li>4096 байт для каждого файла cookie</li>
				<li>20 файлов cookie для каждого домена</li>
				<li>81920 байт для каждого домена (задано 20 файлов cookie максимального размера 4096 = 81920 байт.)</li>
			</ul>
		</li>
		<li>
			<b>sessionStorage</b>
			<br />
			<b>Плюсы:</b>
			<ul>
				<li>Он похож на localStorage.</li>
				<li>Изменения доступны только для каждого окна (или вкладки в браузерах, таких как Chrome и Firefox). Сделанные изменения сохраняются и доступны для текущей страницы, а также для будущих посещений сайта в том же окне. Когда окно закрыто, хранилище удаляется.</li>
			</ul>
			<b>Минусы:</b>
			<ul>
				<li>Данные доступны только внутри окна/вкладки, в котором он был установлен.</li>
				<li>Данные не сохраняются, т.е. будут потеряны после закрытия окна/вкладки.</li>
				<li>Подобно localStorage, работает в политике одинакового происхождения. Таким образом, сохраненные данные будут доступны только в том же месте.</li>
			</ul>
		</li>
	</ul>
	<b>Подробней:</b>
	<ul>
		<li>LocalStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/localStorage</li>
		<li>Cookies: https://developer.mozilla.org/ru/docs/Web/HTTP/Куки</li>
		<li>SessionStorage: https://developer.mozilla.org/ru/docs/Web/API/Window/sessionStorage</li>
	</ul>
</div>
</details>

<details>
<summary>Каким способом, возможно вложить js-объект в localstorage?</summary>
<div>
	<br />
	<p>localStorage.setItem(‘Object’, JSON.stringify(Object))</p>
</div>
</details>

<details>
<summary>Нужно ли в 5-м ХТМЛ закрывать /> одиночные теги ?</summary>
<div>
	<br />
	<p>По спецификации - не нужно. Закрывающие слэши предполагаются в XHTML, а в HTML (любой версии) они не нужны.</p>
	<p>По здравому смыслу - тоже не нужно. Валидатор w3c так же не ругается.</p>
</div>
</details>

<details>
<summary>Что такое кэш приложения в HTML5?</summary>
<div>
	<br />
	<p>Доступность в оффлайне становится всё более важной для веб-приложений. Да, все браузеры имеют механизмы кэширования, но они ненадежны и работают не всегда ожидаемо. HTML5 устраняет некоторые из этих неприятностей с помощью интерфейса ApplicationCache.</p>
	<p>Использование интерфейса кэша даёт вашему приложению три преимущества:</p>
	<ul>
		<li>автономный просмотр — пользователи могут исследовать ваш сайт целиком, когда они находятся в оффлайне;</li>
		<li>скорость — ресурсы кэшируются локально, поэтому загружаются быстрее;</li>
		<li>снижение нагрузки на сервер — браузер загружает с сервера только изменённые ресурсы.</li>
		<li>Кэш приложения (или AppCache) позволяет разработчику указать, какие файлы браузер должен кэшировать и сделать доступными для оффлайновых пользователей. Ваше приложение будет работать корректно, даже если пользователь нажимает кнопку «Обновить», находясь в автономном режиме.</li>
	</ul>
	<p>
		Подробней, как настроить и обновлять: http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya
	</p>
</div>
</details>

<details>
<summary>Дайте описание след. разделам в файле манифеста кеша: CACHE, NETWORK и FALLBACK.</summary>
<div>
	<br />
	<ul>
		<li>CACHE - Это стандартный раздел для записи. Файлы, перечисленные в этом блоке (или сразу после  CACHE MANIFEST) будут явно кэшированы после того как они скачаны в первый раз.</li>
		<li>NETWORK - Файлы, перечисленные в этом разделе, это ресурсы, которые требуют подключения к серверу. Все запросы к этим ресурсам идут в обход кэша, даже если пользователь находится в оффлайне. Можно использовать * для задания шаблона.</li>
		<li>FALLBACK Дополнительный раздел указывает резервные страницы, если ресурс недоступен. Первый URL является ресурсом, второй резервом. Оба адреса должны быть относительны и быть в том же месте, что и файл манифеста. Можно использовать * для задания шаблона.</li>
	</ul>
	<p>
		Подробней, как настроить и обновлять: http://htmlbook.ru/blog/rukovodstvo-po-ispolzovaniyu-kesha-prilozheniya
	</p>
</div>
</details>

<details>
<summary>Объясните разницу между ```<script>, <script async> и <script defer>```</summary>
<div>	
	<br />
	<b>Просто script с src:</b>
	<br />
	<ul>
		<li>Получить страницу HTML (например, index.html)</li>
		<li>Начните синтаксический анализ HTML</li>
		<li>Парсер встречает тег ```<script>```, ссылающийся на внешний файл script.</li>
		<li>Браузер запрашивает файл script. Между тем, синтаксический анализатор блокирует и останавливает анализ другого HTML на вашей странице.</li>
		<li>Через некоторое время загрузится и затем выполняется script.</li>
		<li>Парсер продолжает анализировать остальную часть HTML-документа.</li>
	</ul>
	<p>
		<b>async</b>: Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении ```<script async src="...">``` браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен – он выполнится.
	</p>
	<p>
		<b>defer</b>: Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.
	</p>
	<p>
		Первое – браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.
	</p>
	<p>
		Второе отличие – скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.
	</p>
	<p>
		Подробнее: https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async
	</p>
</div>
</details>

<details>
<summary>Какое будет поведение ```<script async defer>```?</summary>
<div>
	<br />
	<p>При одновременном указании async и defer в современных браузерах будет использован только async, в IE9- – только defer (не понимает async).</p>
	<p>
		Подробнее: https://learn.javascript.ru/external-script#асинхронные-скрипты-defer-async
	</p>
</div>
</details>

<details>
<summary>Что такое прогрессивный рендеринг?</summary>
<div>
	<br />
	<p> Прогрессивное рендеринг - это имя, данное методам, используемым для рендеринга содержимого для отображения как можно быстрее. Раньше он был гораздо более распространенным в дни перед широкополосным доступом в Интернет, но он по-прежнему полезен в современном развитии, поскольку мобильные соединения данных становятся все более популярными (и ненадежными!)</p>
	<b>Примеры таких методов:</b>
	<ul>
		<li>Ленивая загрузка изображений, где (как правило) некоторые javascript загружают изображение, когда оно попадает в окно просмотра браузеров, вместо загрузки всех изображений при загрузке страницы.</li>
		<li>Приоритет видимого содержимого (или выше рендеринга сложения), где вы включаете только минимальные css/content/скрипты, необходимые для количества страницы, которая будет отображаться в чтобы браузер отображался как можно быстрее, вы можете использовать отложенный javascript (domready/load) для загрузки других ресурсов и контента.</li>
	</ul>
	<b>Подробнее:</b>
	<ul>
		<li>Совсем глубоко: https://habrahabr.ru/post/210558/</li>
		<li>Как рендерит: https://habrahabr.ru/post/224187/</li>
		<li>https://habrahabr.ru/post/320430/</li>
		<li>https://stackoverflow.com/questions/33651166/what-is-progressive-rendering</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое meta теги?</summary>
<div>
	<br />
	<p>```<meta>``` определяет метатеги, которые используются для хранения информации предназначенной для браузеров и поисковых систем. Например, механизмы поисковых систем обращаются к метатегам для получения описания сайта, ключевых слов и других данных. Разрешается использовать более чем один метатег, все они размещаются в контейнере ```<head>```. Как правило, атрибуты любого метатега сводятся к парам «имя=значение», которые определяются ключевыми словами content, name или http-equiv.</p>
	<b>Аттрибуты:</b>
	<ul>
		<li>charset: Задает кодировку документа.</li>
		<li>content: Устанавливает значение атрибута, заданного с помощью name или http-equiv.</li>
		<li>http-equiv: Предназначен для конвертирования метатега в заголовок HTTP.</li>
		<li>name: Имя метатега, также косвенно устанавливает его предназначение.</li>
	</ul>
	<p>
		Подробнее об аттрибутах: http://htmlbook.ru/html/META
	</p>
</div>
</details>

<details>
<summary>Как можно с помощью meta-тега, указать HTTP - заголовок?</summary>
<div>
	<br />

`<meta http-equiv="Content-Type" content="text/html" />`

<p>
	Много подброней: https://ru.wikipedia.org/wiki/Метатеги
</p>
</div>
</details>

<details>
<summary>Расскажите о meta-теге с name=viewport</summary>
<div>
	<br />
	<p>Типичный сайт, оптимизированный для мобильных устройств, содержит следующий мета-тег:</p>

```html
<meta name="viewport" content="width=device-width, initial-scale=1" />
```

<p>Свойство width определяет размер окна просмотра. Он может быть установлен на определенное количество пикселей, скажем,width=600 или на специальное значение device-width, которое означает ширину экрана в пикселях CSS в масштабе 100%. (Есть также соответствующие значения height и device-height, которые могут быть полезны для страниц с элементами, которые изменяют размер или положение на основе высоты окна просмотра).</p>
<p>Свойство initial-scale контролирует уровень масштабирования при первой загрузке страницы. Свойства maximum-scale, minimum-scale и user-scalable определяют, как пользователям разрешено увеличивать или уменьшать страницу.</p>
<p>"user-scalable=no" запрещается любое масштабирование</p>
<p>
	Подброней: https://developer.mozilla.org/ru/docs/Mozilla/Mobile/Viewport_meta_tag
</p>
</div>
</details>

<details>
<summary>Какие теги практически обязательно должны быть в ```head```?</summary>
<div>
	<br />

```html
<meta charset="utf-8" /> <meta http-equiv="x-ua-compatible" content="ie=edge" />
<!-- Use the content="ie-edge" tag if your project
    supports Internet Explorer prior to version 11. -->
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/>
<title>Page Title</title>
```

<p>
	Много больше информации о том, что должно быть в head: https://gethead.info/
</p>
</div>
</details>

<details>
<summary>Есть ли разница: `meta charset="utf-8"` и `meta http-equiv="Content-Type" content="text/html; charset=utf-8"`?</summary>
	<p>В HTML5 они эквивалентны</p>
	<p>Используйте ```meta charset="utf-8"``` для веб-браузеров при использовании HTML5.</p>
	<p>Используйте ```meta http-equiv="Content-Type" content="text/html; charset=utf-8"``` при использовании HTML4 или XHTML или для устаревших парсеров dom, например DOMDocument в php</p>
</details>

<details>
<summary>Как сделать чтобы все гиперссылки сайта открывались в новом окне, т.е чтобы по умолчанию использовался `target="_blank"`?</summary>
<div>
	<br />
	<p>Нужно в области head прописать тег base с атрибутом `target="_blank"`:</p>

```html
<head>
  <base target="”_blank”" />
</head>
```

</div>
</details>

<details>
<summary>А как теперь быть, если какую-то из гиперссылок я захочу открыть в этом же окне, т.е. не создавая новое?</summary>
<div>
	<br />
	<p>В тег `a` этой ссылки вам уже нужно будет добавить атрибут `target="_self"`, ибо по умолчанию сейчас у нас используется `target="_blank"`</p>
</div>
</details>

<details>
<summary>Что такое аттрибут target и какие значения он принимает и что делает?</summary>
<div>
	<br />
	<p>По умолчанию, при переходе по ссылке документ открывается в текущем окне или фрейме. При необходимости, это условие может быть изменено атрибутом target тега <a>. В XHTML применение этого атрибута запрещено. Все значения аттрибуты начинаются с \_</p>
	<ul>
		<li><b>blank</b> - Загружает страницу в новое окно браузера.</li>
		<li><b>self</b> - Загружает страницу в текущее окно.</li>
		<li><b>parent</b> - Загружает страницу во фрейм-родитель, если фреймов нет, то это значение работает как self.</li>
		<li><b>top</b> - Отменяет все фреймы и загружает страницу в полном окне браузера, если фреймов нет, то это значение работает как self.</li>
	</ul>
	<p>Подробней: http://htmlbook.ru/html/a/target</p>
</div>
</details>

<details>
<summary>Что такое абсолютная и относительная ссылка?</summary>
<div>
	<br />
	<ul>
		<li>

`<a href=”http://google.com/example.html”>Абсолютная ссылка</a>`

</li>
		<li>

`<a href=”../../example.html”>Относительная ссылка</a>`

</li>
	</ul>
</div>
</details>

<details>
<summary>Какие новые элементы форм введены в HTML 5?</summary>
<div>
	<br />
	<b>В HTML 5 введены десять новых важных элементов форм:</b>
	<ul>
		<li>Color;</li>
		<li>Date;</li>
		<li>Datetime-local;</li>
		<li>Email;</li>
		<li>Time;</li>
		<li>Url;</li>
		<li>Range;</li>
		<li>Telephone;</li>
		<li>Number;</li>
		<li>Search;</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое элемент datalist в HTML 5?</summary>
<div>
	<br />
	<p>Элемент datalist в HTML 5 помогает реализовать функцию автозаполнения в поле для ввода.</p>

```html
<input list="Country" />
<datalist id="Country">
  <option value="India"></option>
  <option value="Italy"></option>
  <option value="Iran"></option>
  <option value="Israel"></option>
  <option value="Indonesia"></option>
</datalist>
```

<p>
	Подробней: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist
</p>
</div>
</details>

<details>
<summary>Что такое элемент output в HTML 5?</summary>
<div>
	<br />
	<p>Элемент output требуется, когда вы хотите отобразить сумму двух введённых чисел в виде текста. Например, у вас есть два поля для ввода и вы хотите сложить числа из этих двух полей и отобразить их сумму в виде текста. Ниже приведён пример использования элемента output в HTML 5:</p>

```html
<form
  onsubmit="return false"
  oninput="o.value = parseInt(a.value) + parseInt(b.value)"
>
  <input name="a" type="number" /> + <input name="b" type="number" /> =
  <output name="o" />
</form>
```

<p>Вы можете заменить «parseInt» на «valueAsNumber» для простоты. Также вы можете использовать атрибут «for» элемента output для повышения читаемости.</p>

```html
<output name="o" for="a b"></output>
```

<p>
	Подробней: http://htmlbook.ru/blog/element-output
</p>
</div>
</details>

<details>
<summary>Что такое свойство valueAsNumber?</summary>
<div>
	<br />
	<p>В HTML5 представлено свойство JavaScript valueAsNumber для полей формы (в частности: number, date, range). Оно возвращает значение в виде числа, а не строки, то есть нам больше не нужно использовать parseInt или parseFloat, и оператор + складывает, а не склеивает.</p>

```html
<form
  onsubmit="return false"
  oninput="o.value = a.valueAsNumber + b.valueAsNumber"
>
  <input name="a" id="a" type="number" step="any" /> +
  <input name="b" id="b" type="number" step="any" /> =
  <output name="o" for="a b"></output>
</form>
```

<p>
	Подробней: http://htmlbook.ru/blog/element-output
</p>
</div>
</details>

<details>
<summary>Для чего нужен атрибут autocomplete? Какие параметры принимает?</summary>
<div>
	<br />
	<p>Этот атрибут помогает заполнять поля форм текстом, который был введён в них ранее. Значения сохраняет и подставляет браузер, при этом автозаполнение по соображениям безопасности может отключаться пользователем в настройках и не может в таком случае управляться атрибутом autocomplete.</p>
	<ul>
		<li><b>on</b> - Включает автозаполнение текста.</li>
		<li><b>off</b> - Отключает автозаполнение. Это значение обычно используется для отмены сохранения в браузере важных данных (паролей, номеров банковских карт), а также редко вводимых или уникальных данных (капча).</li>
	</ul>
	<p>
		Подробней: http://htmlbook.ru/html/input/autocomplete
	</p>
</div>
</details>

<details>
<summary>Какой формат у input type="date" в HTML5</summary>
<div>
	<br />
	<p>YYYY-MM-DD</p>
</div>
</details>

<details>
<summary>Какой метод запускает проигрывание аудио-файла?</summary>
<div>
	<br />
	<p>var sound = new Audio(«file.wav»);</p>
	<p>sound.play();</p>
</div>
</details>

<details>
<summary>Какой формат видео файлов сейчас поддерживается html5?</summary>
<div>
	<br />
	<p>MPEG 4</p>
</div>
</details>

<details>
<summary>Какие элементы в HTML5 могут иметь aria атрибут?</summary>
<div>
	<br />
	<p>Любой элемент</p>
</div>
</details>

<details>
<summary>Знаете ли вы тег <b>dfn</b> и за что он отвечает?</summary>
<div>
	<br />
	<p>Как правило, в документе, когда упоминается новый термин, он выделяется курсивом и дается его определение. При использовании этого термина в дальнейшем, он считается уже известным читателю. Тег <b>dfn</b> применяется для выделения таких терминов при их первом появлении в тексте.</p>
	<p>Браузеры отображают содержимое контейнера <dfn> с помощью курсивного начертания.</p>
	<p>Подробней: http://htmlbook.ru/html/DFN</p>
</div>
</details>

<details>
<summary>Что такое SVG?</summary>
<div>
	<br />
	<p>язык разметки масштабируемой векторной графики, созданный Консорциумом Всемирной паутины (W3C) и входящий в подмножество расширяемого языка разметки XML, предназначен для описания двумерной векторной и смешанной векторно/растровой графики в формате XML. Поддерживает как неподвижную, так и анимированную интерактивную графику — или, в иных терминах, декларативную и скриптовую.</p>
	<p>
		Подробней: https://ru.wikipedia.org/wiki/SVG
	</p>
</div>
</details>

<details>
<summary>Что такое canvas в HTML 5?</summary>
<div>
	<p>Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript). Он может, к примеру, использоваться для рисования графов, создания коллажей или простой (и не очень) анимации. Изображения в правой части статьи являются примерами использования <canvas>, примеры их создания приводятся в этой статье.</p>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial
	</p>
</div>
</details>

<details>
<summary>В чём разница между canvas и SVG?</summary>
<div>
	<br />
	<ul>
		<li>
			<b>SVG</b>
			<br />
			<b>Плюсы:</b>
			<ul>
				<li>Нет зависимости от разрешения — SVG лучше подходит для кроссплатформенных пользовательских интерфейсов, так как позволяет масштабировать изображение при различных разрешениях экрана.</li>
				<li>SVG очень хорошо поддерживает анимацию. Элементы могут быть анимированы с использованием описательного синтаксиса или с помощью JavaScript.</li>
				<li>Можно получить полный контроль над каждым элементом, используя SVG DOM API в JavaScript.</li>
				<li>SVG хранится в формате XML, что предоставляет больше возможностей браузерам по обеспечению доступности SVG документов по сравнению с элементом canvas. Таким образом, SVG выглядит лучшим решением для пользовательских интерфейсов веб-приложений.</li>
			</ul>
			<b>Минусы:</b>
			<ul>
				<li>Низкая скорость рендеринга при увеличении сложности документа (рисунка), так как используется модель DOM</li>
				<li>Скорее всего, SVG не подходит для таких приложений как игры. Возможно лучшим выбором будет комбинация HTML Canvas + SVG.</li>
			</ul>
		</li>
		<li>
			<b>Canvas</b>
			<br />
			<b>Плюсы:</b>
			<ul>
				<li>Высокая производительность при отрисовке любых 2D объектов.</li>
				<li>Стабильная производительность — всё есть пиксель. Производительность падает только при увеличении разрешения изображения.</li>
				<li>Можно сохранить полученное изображение в PNG или JPG файл.</li>
				<li>Лучше всего подходит для создания растровой графики (например, в играх, фракталов и т.п.), редактирования изображений и операций, требующих манипулирования на уровне пикселей.</li>
			</ul>
			<b>Минусы:</b>
			<ul>
				<li>Отрисовка основана на пикселях.</li>
				<li>Не существует API для анимации. Вам придется прибегать к использованию таймеров и других событий для обновления канвы.</li>
				<li>Слабые возможности по рендерингу текста.</li>
				<li>Возможно, не самый лучший выбор, когда доступность имеет решающее значение. Канва предоставляет вам поверхность для рисования в выбранном контексте (2D и 3D). Можно указать альтернативный контент внутри элемента canvas, который будет показан браузером при невозможности отображения графики. Кроме того, вы можете выполнить проверку доступности выбранного Canvas API с помощью JavaScript. На основе этого вы можете обеспечить различную функциональность для пользователей браузеров с разной поддержкой HTML 5 Canvas.</li>
				<li>HTML 5 Canvas не подходит для создания веб-сайтов или интерфейсов веб-приложений, так как пользовательские интерфейсы обычно должны быть динамическими и интерактивными, а Canvas требует от вас постоянной перерисовки каждого элемента в интерфейсе.</li>
			</ul>
		</li>
	</ul>
	<b>Подробней:</b>
	<ul>
		<li>https://habrahabr.ru/company/simbirsoft/blog/332750/</li>
		<li>https://developer.mozilla.org/ru/docs/Web/API/Canvas_API/Tutorial</li>
	</ul>
</div>
</details>

<details>
<summary>В каких случаях лучше выбрать canvas, а в каких svg?</summary>
<div>
	<br />
	<ul>
		<li>
			<b>HTML 5 Canvas следует использовать для:</b>
			<ul>
				<li>Редактирования изображений: обрезки, изменения размеров, фильтров (удаления эффекта красных глаз, создания эффекта сепии, изменения цветности или яркости)</li>
				<li>Создания растровой графики: визуализации данных, создания фракталов и графиков функций.</li>
				<li>Анализа изображений: создания гистограмм и т.п.</li>
				<li>Создания игровой графики, такой как спрайты и фоны.</li>
			</ul>
		</li>
		<li>
			<b>SVG следует использовать для:</b>
			<ul>
				<li>Создания пользовательских интерфейсов веб-приложений, независимых от разрешения экрана.</li>
				<li>Высокоинтерактивных анимированных пользовательских интерфейсов.</li>
				<li>Графиков и диаграмм.</li>
				<li>Редактирования векторных изображений.</li>
			</ul>
		</li>
	</ul>
</div>
</details>

<details>
<summary>Что такое WebGL?</summary>
<div>
	<br />
	<p>WebGL (Web-based Graphics Library) — программная библиотека для языка программирования JavaScript, позволяющая создавать на JavaScript интерактивную 3D-графику, функционирующую в широком спектре совместимых с ней веб-браузеров. За счёт использования низкоуровневых средств поддержки OpenGL, часть кода на WebGL может выполняться непосредственно на видеокартах. WebGL — это контекст элемента canvas HTML, который обеспечивает API 3D графики без использования плагинов. Спецификация версии 1.0 была выпущена 3 марта 2011 года. Проект по созданию библиотеки управляется некоммерческой организацией Khronos Group.</p>
	<p>Подробней: https://ru.wikipedia.org/wiki/WebGL</p>
</div>
</details>

<details>
<summary>Перечислите блочные элементы, которые Вам известны(хотя бы 5).</summary>
<div>
	<br />
	<p>

`<address>, <article>, <aside>, <audio>, <blockquote>, <canvas>, <dd>, <div>, <dl>, <fieldset>, <figcaption>, <figure>, <footer>, <form>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <header>, <hgroup>, <hr>, <li>, <main>, <nav>, <noscript>, <ol>, <output>, <p>, <pre>, <section>, <table>, <tfoot>, <ul>, <video>`

</p>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/HTML/Block-level_elements
	</p>
</div>
</details>

<details>
<summary>Перечислите строчные элементы, которые Вам известны(хотя бы 5).</summary>
<div>
	<br />
	<ul>
		<li>

`b, big, i, small, tt`

</li>
		<li>
			
```abbr, acronym, cite, code, dfn, em, kbd, strong, samp, time, var```

</li>
		<li>

`a, bdo, br, img, map, object, q, script, span, sub, sup`

</li>
		<li>

`button, input, label, select, textarea`

</li>
	</ul>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/HTML/Строчные_Элементы
	</p>
</div>
</details>

<details>
<summary>Дайте пояснения, для какой цели добавленны след. элементы: <b>article</b>, <b>aside</b>, <b>audio</b>, <b>canvas</b>, <b>figcaption</b>, <b>figure</b>, <b>footer</b>, <b>header</b>, <b>hgroup</b>, <b>output</b>, <b>section</b>, <b>video</b>. (Кратко)</summary>
<div>
	<br />
	<ul>
		<li><b>article</b>: Тег <b>article</b> задает содержание сайта вроде новости, статьи, записи блога, форума или др. Элемент  должен содержать часть самодостаточной информации, которая может быть вырвана из контекста всей страницы без потери смысла.</li>
		<li><b>aside</b>: Определяет блок сбоку от контента для размещения рубрик, ссылок на архив, меток и другой информации. Такой блок, как правило, называется «сайдбар» или «боковая панель».</li>
		<li><b>audio</b>: Добавляет, воспроизводит и управляет настройками аудиозаписи на веб-странице. Путь к файлу задается через атрибут src или вложенный тег <b>source</b>. Внутри контейнера <b>audio</b> можно написать текст, который будет выводиться в браузерах, не работающих с этим тегом.</li>
		<li><b>canvas</b>: Это HTML элемент, использующийся для рисования графики средствами языков программирования (обычно это JavaScript).</li>
		<li><b>figcaption</b>: Содержит описание для тега <b>figure</b>. Тег <b>figcaption</b> должен быть первым или последним элементом в группе.</li>
		<li><b>figure</b>: Используется для группирования любых элементов, например, изображений и подписей к ним.</li>
		<li><b>footer</b>: Тег <b>footer</b> задаёт «подвал» сайта или раздела, в нём может располагаться имя автора, дата документа, контактная и правовая информация.</li>
		<li><b>header</b>: Тег <b>header</b> задает «шапку» сайта или раздела, в которой обычно располагается заголовок.</li>
		<li><b>hgroup</b>: Используется для группирования заголовков веб-страницы или раздела. Внутри располагаются теги заголовков от <b>h1</b> до <b>h6</b>. Данный тег исключён из версии HTML от W3C, но остался в версии WHATWG, будущее элемента пока не определено.</li>
		<li><b>output</b>: Определяет область в которую выводится информация, преимущественно с помощью скриптов.</li>
		<li><b>section</b>: Задаёт раздел документа, может применяться для блока новостей, контактной информации, глав текста, вкладок в диалоговом окне и др. Раздел обычно содержит заголовок. Допускается вкладывать один тег <b>section</b> внутрь другого.</li>
		<li><b>video</b>: Добавляет, воспроизводит и управляет настройками видеоролика на веб-странице. Путь к файлу задается через атрибут src или вложенный тег <b>source</b>.</li>
	</ul>
	<b>Подробней:</b>
	<ul>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/article</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/aside</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/audio</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/canvas</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/figure</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/footer</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/header</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/hgroup</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/section</li>
		<li>https://developer.mozilla.org/ru/docs/Web/HTML/Element/video</li>
	</ul> 
</div>
</details>

<details>
<summary>На какие события <b>video</b> или <b>audio</b> можно подписаться?(Кандидат может не знать ни одного. Это легко гуглится в работе)</summary>
<div>
	<br />
	<p><b>abort</b>, <b>canplay</b>, <b>ended</b>, <b>loadstart</b>, <b>pause</b>, <b>play</b>, <b>playing</b></p>
	<p>Подробней: https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Media_events</p>
</div>
</details>

<details>
<summary>Чем отличается article от section?</summary>
<div>
	<br />
	<b>Чтобы не было путаницы, разберём где и когда использовать разные контейнеры:</b>
	<ul>
		<li><b>div</b> — контейнер общего назначения, не обязательно смысловой. Дивы используются для разметки мелких блоков, создания сетки и декоративных эффектов.</li>
		<li><b>section</b> — более крупный логический контейнер, объединяющий содержание по смыслу. Например, блок «О компании», список товаров, раздел личной информации в профиле и так далее.</li>
		<li><b>article</b> — самостоятельный, цельный и независимый раздел документа. Этот раздел можно в неизменном виде использовать в различных местах, в том числе и на других сайтах. Примеры: статья, пост в блоге, сообщение на форуме и так далее.</li>
	</ul>
	<p>
		Подробней: https://habrahabr.ru/post/214407/
	</p>
</div>
</details>

<details>
<summary>Для чего нужен тег <b>noscript</b>?</summary>
<div>
	<br />
	<p>Элемент HTML <b>noscript</b> определяет секцию html кода, которая будет вставлена, если в браузере пользователя нет либо отключена поддержка JavaScript'а.</p>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/HTML/Element/noscript
	</p>
</div>
</details>

<details>
<summary>Что такое категории контента в HTML5, cколько их, расскажите о них.</summary>
<div>
	<br />
	<p>Каждый элемент HTML принадлежит некоторому количеству категорий контента, которые объединяют элементы с общим набором характеристик. Такая группировка является свободной, то есть не задает на самом деле отношение между элементами таких типов, но помогает определить и описать их поведение и правила, которым они должны следовать, особенно когда дело доходит до сложных деталей. Также возможна ситуация, когда элемент не входит ни в одну из этих категорий.</p>
	<b>Существует три типа категорий контента:</b>
	<ul>
		<li>Основные категории контента, описывающие общие для многих элементов правила;</li>
		<li>Категории контента для элементов форм, описывающие общие правила для элементов форм;</li>
		<li>Особые категории контента, описывающие редкие категории, актуальные только для нескольких элементов, возможно, лишь в особом контексте.</li>
	</ul>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Content_categories
	</p>
</div>
</details>

<details>
<summary>Какие категории считаются основными категориями контента?</summary>
<div>
	<br />
	<ul>
		<li>Метаданные: Элементы, принадлежащие к категории метаданных, изменяют отображение или поведение HTML-документа, связывают его с другими документами и предоставляют другую дополнительную информацию о документе.</li>
		<li>Потоковый контент: Элементы основного потока обычно содержат текст и встроенный контент.</li>
		<li>Секционный контент: Подобные элементы создают секции (блоки) в текущей структуре документа, определяющие область действия заголовочного контента и элементов <b>header</b> и <b>footer</b></li>
		<li>Заголовочный контент: Заголовочный контент задает заголовок секции, явно отмеченной структурным элементом или неявно – самим заголовочным.</li>
		<li>Фразовый контент: Фразовый контент определяет текст и его формат. Серии фразового контента образуют параграфы.</li>
		<li>Встроенный контент: Встроенный контент импортирует в документ другой ресурс или вставляет содержимое на другом языке разметки или принадлежащее другому пространству имен.</li>
		<li>Интерактивный контент: К интерактивному контенту относятся элементы, который специально разработаны для взаимодействия с пользователем.</li>
		<li>Явный контент: Контент считается явным, когда он не скрыт и не является пустым, это контент, который отображен и предметен. У элементов потокового или фразового контента должен быть хотя бы один явный узел.</li>
		<li>Контент форм: Контент форм включает в себя элементы, у которых есть владелец формы, обозначенный атрибутом form. Владелецем формы является либо элемент <b>form</b> либо элемент, id которого указан в атрибуте form.</li>
	</ul>
	<p>
		Подробней: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Content_categories
	</p>
</div>
</details>

<details>
<summary>Отличие <b>i</b> от <b>em</b> и <b>strong</b> от <b>b</b> т. д.?</summary>
<div>
	<br />
	<p>Следует отметить, что теги <b>b</b> и <b>strong</b>, также как <b>i</b> и <b>em</b>, несмотря на сходный результат, не совсем эквивалентны и заменяемы. Первый тег <b>b</b> — относится к тегам физической разметки и устанавливает жирный текст, а тег <b>strong</b> — является тегом логической разметки и определяет важность помеченного текста. Такое разделение тегов на логическое и физическое форматирование изначально предназначалось, чтобы сделать HTML универсальным, в том числе не зависящим от устройства вывода информации. Теоретически, если воспользоваться, например, речевым браузером, то текст, оформленный с помощью тегов <b>b</b> и <b>strong</b>, будет отмечен по-разному. Однако получилось так, что в популярных браузерах результат использования этих тегов равнозначен.</p>
</div>
</details>

<details>
<summary>Можно ли вложить <b>p</b> в другой такой же <b>p</b>? Можно ли вложить <b>div</b> в <b>p</b>?</summary>
<div>
	<br />
	<p>Синтаксически <b>div</b> и <b>p</b> внутри <b>p</b> является недопустимым во всех стандартах HTML. Более того, при использовании соответствующего парсера HTML невозможно разместить элемент <b>div</b> внутри <b>p</b> в DOM, потому что открывающий тег <b>div</b> автоматически закрывает элемент <b>p</b>.</p>
</div>
</details>

<details>
<summary>Какие теги запрещены в html5? (хотя бы 3, не страшно если ни одного)</summary>
<div>
	<br />

`<applet> <ins> <col />, <colgroup> <area /> <basefont /> <center> <bdo> <dir> <font> <frame /> <frameset> <iframe> <isindex> <noframes> <strike> <u> <tbody> <tfoot> <thead>`

</div>
</details>

<details>
<summary>Чем отличается класс (class) от идентификатора (id) в HTML?</summary>
<div>
	<br />
	<b>Идентификаторы:</b>
	<ul>
		<li>В коде документа каждый идентификатор уникален и должен быть включён лишь один раз.</li>
		<li>Имя идентификатора чувствительно к регистру.</li>
		<li>Через метод getElementById можно получить доступ к элементу по его идентификатору и изменить свойства элемента.</li>
		<li>Стиль для идентификатора имеет приоритет выше, чем у классов.</li>
	</ul>
	<b>Классы:</b>
	<ul>
		<li>Классы могут использоваться в коде неоднократно.</li>
		<li>Имена классов чувствительны к регистру.</li>
		<li>Классы можно комбинировать между собой, добавляя несколько классов к одному тегу.</li>
	</ul>
</div>
</details>

<details>
<summary>Какое событие сработает при потери фокуса элементом формы?</summary>
<div>
	<br />
	<p>Событие onblur возникает при потере элемента фокуса. Это обычно происходит, если щелкнуть на другой элемент текущего документа. Событие onblur противоположно по своему действию событию onfocus.</p>
	<b>Подробенй:</b>
	<ul>
		<li>http://htmlbook.ru/html/attr/onBlur</li>
		<li>https://developer.mozilla.org/ru/docs/Web/Events/blur</li>
	</ul>
</div>
</details>

<details>
<summary>Для чего существует тег <b>q</b>?</summary>
<div>
	<br />
	<p>Тег <b>q</b> используется для выделения в тексте цитат. Содержимое контейнера автоматически отображается в браузере в кавычках.</p>
	<p>Подробней: http://htmlbook.ru/html/Q</p>
</div>
</details>

<details>
<summary>Что такое "Якорь"?</summary>
<div>
	<br />
	<p>Якорем называется закладка с уникальным именем на определенном месте веб-страницы, предназначенная для создания перехода к ней по ссылке. Якоря удобно применять в документах большого объема, чтобы можно было быстро переходить к нужному разделу.</p>
	<p>Подробней: http://htmlbook.ru/samhtml/yakorya</p>
</div>
</details>

<details>
<summary>Расскажите про тег <b>keygen</b></summary>
<div>
	<br />
	<p>Используется для генерации пары ключей — закрытого и открытого. Когда форма отправляется на сервер, закрытый ключ сохраняется на локальном компьютере, а открытый ключ передается вместе с формой. Сами ключи необходимы для шифрования и расшифровки данных, создания и проверки цифровой подписи.</p>
	<b>Подробней:</b>
	<ul>
		<li>http://htmlbook.ru/html/KEYGEN</li>
		<li>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/keygen</li>
	</ul>
</div>
</details>

<details>
<summary>Для олдскульных ребят, существует ли тег <b>basefont</b> и за что он отвечает?</summary>
<div>
	<br />
	<p>Не существует, ни за что не отвечает</p>
	<p>Существовал, убран из html5</p>
	<p>Тег <b>basefont</b> предназначен для задания шрифта, размера и цвета текста по умолчанию. Указанные значения будут использоваться во всем документе за исключением тега <b>font</b>, в котором можно переопределить параметры оформления текста. Допускается использование тега в контейнере <b>head</b> или <b>body</b>, причем несколько раз. Это позволяет изменять вид шрифта для части документа.</p>
	<p>Подробней: http://htmlbook.ru/html/basefont</p>
</div>
</details>

## [репозиторий автора →](https://github.com/yofi2tofi)
